<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>Marcin Copik | String formatting with optional values</title>
<meta name="description" content="Personal webpage">

<!-- Open Graph -->


<!-- Bootstrap & MDB -->
<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet" integrity="sha512-MoRNloxbStBcD8z3M/2BmnT+rg4IsMxPkXaGh2zD6LGNNFE80W3onsAhRcMAMrSoyWL9xD7Ert0men7vR8LUZg==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/css/mdb.min.css" integrity="sha512-RO38pBRxYH3SoOprtPTD86JFOclM51/XTIdEPh5j8sj4tp8jmQIx26twG52UaLi//hQldfrh7e51WzP9wuP32Q==" crossorigin="anonymous" />

<!-- Fonts & Icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css"  integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.1/css/academicons.css" integrity="sha512-WgL+hxwL4NdLGGZ4Euo/BmGAcQgyRRJsTQbNPGui+nWlzaF+3f2zf2rh578ccU3YINJCi8LvHyV1OHLJ8effBA==" crossorigin="anonymous">
<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

<!-- Code Syntax Highlighting -->
<link rel="stylesheet" href="https://gitcdn.xyz/repo/jwarby/jekyll-pygments-themes/master/github.css" />

<!-- Styles -->

<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ”¥</text></svg>">

<link rel="stylesheet" href="/assets/css/main.css">
<link rel="canonical" href="/blog/2018/string-format-optional/">

<!-- JQuery -->
<!-- jQuery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>


<!-- Theming-->

<script src="/assets/js/theme.js"></script>
<script src="/assets/js/dark_mode.js"></script>






    
<!-- MathJax -->
<script type="text/javascript">
  window.MathJax = {
    tex: {
      tags: 'ams'
    }
  };
</script>
<script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js"></script>
<script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>


  </head>

  <body class="fixed-top-nav ">

    <!-- Header -->

    <header>

    <!-- Nav Bar -->
    <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
    <div class="container">
      
      <a class="navbar-brand title font-weight-lighter" href="/">
       Marcin Copik
      </a>
      
      <!-- Navbar Toggle -->
      <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar top-bar"></span>
        <span class="icon-bar middle-bar"></span>
        <span class="icon-bar bottom-bar"></span>
      </button>
      <div class="collapse navbar-collapse text-right" id="navbarNav">
        <ul class="navbar-nav ml-auto flex-nowrap">
          <!-- About -->
          <li class="nav-item ">
            <a class="nav-link" href="/">
              about
              
            </a>
          </li>
          
          <!-- Blog -->
          <li class="nav-item active">
            <a class="nav-link" href="/blog/">
              blog
              
            </a>
          </li>
          
          <!-- Other pages -->
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/projects/">
                projects
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/publications/">
                publications
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/talks/">
                talks
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/students/">
                students
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/misc/">
                miscellaneous
                
              </a>
          </li>
          
          
          <li class="nav-item">
            <a class="nav-link" href="/assets/pdf/cv.pdf" target="_blank" rel="nofollow">
              CV
            </a>
          </li>
          
            <div class = "toggle-container">
              <a id = "light-toggle">
                  <i class="fas fa-moon"></i>
                  <i class="fas fa-sun"></i>
              </a>
            </div>
          
        </ul>
      </div>
    </div>
  </nav>

</header>


    <!-- Content -->

    <div class="container mt-5">
      

<div class="post">

  <header class="post-header">
    <h1 class="post-title">String formatting with optional values</h1>
    <p class="post-meta">July 28, 2018</p>
  </header>

  <article class="post-content">
    <p>There are many simple C++ patterns which I use frequently. One of them is using a simple wrapper for C <code class="language-plaintext highlighter-rouge">snprintf</code>. Itâ€™s much easier to use than stringstreams and itâ€™s a nice alternative for small projects where I donâ€™t want to immediately add dependencies such as the popular <a href="https://github.com/fmtlib/fmt">fmt</a> library.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="nf">to_str</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span> 
  <span class="k">return</span> <span class="n">t</span><span class="p">.</span><span class="n">c_str</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="nf">to_str</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">t</span><span class="p">.</span><span class="n">c_str</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// universal reference here would be always selected, including std::string</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">T</span> <span class="nf">to_str</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">t</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="nf">cppsprintf</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">format</span><span class="p">,</span> <span class="n">Args</span> <span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span><span class="n">s</span>
  <span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">format</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">to_str</span><span class="p">(</span><span class="n">args</span><span class="p">)...)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">[]</span><span class="o">&gt;</span> <span class="n">buf</span><span class="p">(</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span> <span class="n">size</span> <span class="p">]</span> <span class="p">);</span>
  <span class="n">snprintf</span><span class="p">(</span> <span class="n">buf</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">size</span><span class="p">,</span> <span class="n">format</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">to_str</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">buf</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">buf</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>The additional <code class="language-plaintext highlighter-rouge">to_str</code> function is added for a very simple reason: <code class="language-plaintext highlighter-rouge">snprintf</code> can only process C strings. For each C++ <code class="language-plaintext highlighter-rouge">std::string</code>, the underlying character array needs to be accessed via <code class="language-plaintext highlighter-rouge">c_str</code> and passed to the function. Itâ€™s quite to forget that since neither error nor warning is generated by default and an automatic conversion is simply much more convenient.</p>

<p>In my recent project, I worked on an LLVM analysis where I had to obtain a string representation of certain IR instructions. This process does not always succeeds since quite often it is not possible to determine a source memory location or variable name. Thus, conversion functions must return two types of values: a correctly processed string or nothing. There are many ways of achieving that: return a null pointer, return a string encoding failed conversion, error flags, exceptions, but nothing beats optional value when it comes to achieving clean and performant code. An optional variable represents a value which might or might not be present. A proper implementation avoids dynamic allocation at all and introduces a neglible overhead, which is unavoidable since it needs to include a boolean flag. Although <code class="language-plaintext highlighter-rouge">std::optional</code> is a recent addition in C++17, it was already available in LLVM as <code class="language-plaintext highlighter-rouge">llvm::Optional</code> for a long time. Obviously, I want to use the <code class="language-plaintext highlighter-rouge">cppsprintf</code> function for an easy formatting but here comes a problem: using an optional value would require a validity check in every use, as it can be seen in the sample below.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">llvm</span><span class="o">::</span><span class="n">Optional</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">convert</span><span class="p">(...)</span>
<span class="p">{</span>
  <span class="n">llvm</span><span class="o">::</span><span class="n">Optional</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">lhs</span> <span class="o">=</span> <span class="n">convert</span><span class="p">(...);</span>
  <span class="n">llvm</span><span class="o">::</span><span class="n">Optional</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">rhs</span> <span class="o">=</span> <span class="n">convert</span><span class="p">(...);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">hasValue</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">.</span><span class="n">hasValue</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">cppsprintf</span><span class="p">(...,</span> <span class="n">lhs</span><span class="p">.</span><span class="n">getValue</span><span class="p">(),</span> <span class="n">rhs</span><span class="p">.</span><span class="n">getValue</span><span class="p">(),</span> <span class="p">...);</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="n">llvm</span><span class="o">::</span><span class="n">Optional</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span></code></pre></figure>

<p>I had a lot of functions where such pattern appears and it would be nice to automatize this process. The first step is to add a simple variadic function which verifies that every passed value is valid. Otherwise, we have to stop and return an empty optional since conversion has failed. The first overload of <code class="language-plaintext highlighter-rouge">all_true</code> function is necessary to stop the recursive call.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="nf">has_value</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="nf">has_value</span><span class="p">(</span><span class="k">const</span> <span class="n">llvm</span><span class="o">::</span><span class="n">Optional</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">t</span><span class="p">.</span><span class="n">hasValue</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="kt">bool</span> <span class="nf">all_true</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Arg</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="nf">all_true</span><span class="p">(</span><span class="k">const</span> <span class="n">Arg</span> <span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">Args</span> <span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
  <span class="p">{</span>
   <span class="k">return</span> <span class="n">has_value</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">all_true</span><span class="p">(</span><span class="n">args</span><span class="p">...);</span>
  <span class="p">}</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">llvm</span><span class="o">::</span><span class="n">Optional</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">cppsprintf</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">format</span><span class="p">,</span> <span class="n">Args</span> <span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">all_true</span><span class="p">(</span><span class="n">args</span><span class="p">...))</span>
      <span class="k">return</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="p">...</span>
  <span class="p">}</span>

</code></pre></div></div>

<p>The second step is to overload <code class="language-plaintext highlighter-rouge">to_str</code> once again to extract the actual value and pass it again recursively since <code class="language-plaintext highlighter-rouge">std::string</code> requires obtaining the C-string representation.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="k">auto</span> <span class="nf">to_str</span><span class="p">(</span><span class="k">const</span> <span class="n">llvm</span><span class="o">::</span><span class="n">Optional</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span> <span class="n">to_str</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&gt;</span><span class="p">())</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">to_str</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">getValue</span><span class="p">());</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>And that is actually sufficient but the new function suffer from a small usability issue - now it <strong>always</strong> returns an optional string, even if the list of arguments does not contain an optional value. It would be really nice if for simple formatting problems we could still obtain a string and avoid unnecessary checks when function always returns a correct value. Fortunately, itâ€™s quite simple to implement with SFINAE, as seen below. Two functions are necessary since we cannot return different types depending on the control flow. The overload is selected based on existence of an <code class="language-plaintext highlighter-rouge">llvm::Optional</code> type in the variadic list of arguments.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="nf">cppsprintf_impl</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">format</span><span class="p">,</span> <span class="n">Args</span> <span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">format</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">to_str</span><span class="p">(</span><span class="n">args</span><span class="p">)...)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">[]</span><span class="o">&gt;</span> <span class="n">buf</span><span class="p">(</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span> <span class="n">size</span> <span class="p">]</span> <span class="p">);</span>
  <span class="n">snprintf</span><span class="p">(</span> <span class="n">buf</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">size</span><span class="p">,</span> <span class="n">format</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">to_str</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">buf</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">buf</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
<span class="k">auto</span> <span class="nf">cppsprintf</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">format</span><span class="p">,</span> <span class="n">Args</span> <span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
  <span class="o">-&gt;</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span> <span class="n">contains_optional</span><span class="o">&lt;</span><span class="n">Args</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="n">llvm</span><span class="o">::</span><span class="n">Optional</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;::</span><span class="n">type</span>
<span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">all_true</span><span class="p">(</span><span class="n">args</span><span class="p">...))</span>
    <span class="k">return</span> <span class="n">llvm</span><span class="o">::</span><span class="n">Optional</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="k">return</span> <span class="nf">cppsprintf_impl</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
<span class="err">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
<span class="k">auto</span> <span class="nf">cppsprintf</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">format</span><span class="p">,</span> <span class="n">Args</span> <span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
  <span class="o">-&gt;</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span> <span class="o">!</span><span class="n">contains_optional</span><span class="o">&lt;</span><span class="n">Args</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&gt;::</span><span class="n">type</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">cppsprintf_impl</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
<span class="err">}</span>

</code></pre></div></div>

<p>Now we only need an actual implementation of <code class="language-plaintext highlighter-rouge">contains_optional</code>. Once again, the variadic pack of types is analyzed one by one and results are accumulated.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Arg</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">contains_optional</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">value</span> <span class="o">=</span>
    <span class="n">is_instance_of</span><span class="o">&lt;</span><span class="n">Arg</span><span class="p">,</span> <span class="n">llvm</span><span class="o">::</span><span class="n">Optional</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">||</span>
    <span class="n">contains_optional</span><span class="o">&lt;</span><span class="n">Args</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Arg</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">contains_optional</span><span class="o">&lt;</span><span class="n">Arg</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">value</span> <span class="o">=</span> <span class="n">is_instance_of</span><span class="o">&lt;</span><span class="n">Arg</span><span class="p">,</span> <span class="n">llvm</span><span class="o">::</span><span class="n">Optional</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

</code></pre></div></div>

<p>The only new thing in this code is the <code class="language-plaintext highlighter-rouge">is_instance_of</code> type. We need to check if the type <code class="language-plaintext highlighter-rouge">Arg</code> an instantation of template <code class="language-plaintext highlighter-rouge">llvm::Optional</code> for some type, in our case mostly <code class="language-plaintext highlighter-rouge">std::string</code>. The standard does not provide a such functionality but it can be implemented in few lines of code. The generic implementation <code class="language-plaintext highlighter-rouge">is_instance_of</code> is defined for a type and a variadic template template parameter. Therefore, we should only inherit from <code class="language-plaintext highlighter-rouge">std::true_type</code> if the first parameter is some instance of the template that we provide as the second parameter</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Is an object of type A</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">A</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">is_instance_of</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">false_type</span><span class="p">{};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">A</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">is_instance_of</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&lt;</span><span class="n">T</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span><span class="p">{};</span>

</code></pre></div></div>

<p>For example, <code class="language-plaintext highlighter-rouge">is_instance_of&lt; std::tuple&lt;int, float&gt;, std::tuple&gt;::value</code> should contain 1 but <code class="language-plaintext highlighter-rouge">is_instance_of&lt; std::tuple&lt;int, float&gt;, std::vector&gt;::value</code> will be zero.</p>

<p>Itâ€™s finally done! We can now safely pass optional values to the formatting function. However, so far we had a C++11 solution with an implementation of optional value coming directly from LLVM. Fortunately for us, C++17 provides three features which can be used to simplify this code.</p>

<h3 id="stdoptional">std::optional</h3>

<p>C++17 includes an implementation of optional value. It has slightly different syntax and both versions can be easily supported with a conditional compilation. Now itâ€™s not necessary to prorvide LLVM headers for the example below.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;optional&gt;
#include &lt;string&gt;
</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">cppsprintf</span><span class="p">(</span><span class="s">"Return value %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="s">"string"</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">cppsprintf</span><span class="p">(</span><span class="s">"Return value correct optional&lt;%s&gt;</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"string"</span><span class="p">)).</span><span class="n">value</span><span class="p">();</span>
<span class="kt">bool</span> <span class="n">value</span> <span class="o">=</span> <span class="n">cppsprintf</span><span class="p">(</span><span class="s">"Return value empty optional %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">()).</span><span class="n">has_value</span><span class="p">();</span>

</code></pre></div></div>

<h3 id="fold-expressions">Fold expressions</h3>

<p>Another addition to the standard are <a href="https://en.cppreference.com/w/cpp/language/fold">fold expressions</a>. In the case of <code class="language-plaintext highlighter-rouge">all_true</code> function, we had to provide recursive implementation of functions to apply simple operators over a variadic parameter pack. With a new syntax, this can be simplified to just using the parameter pack expansion <code class="language-plaintext highlighter-rouge">...</code> with a proper operator!</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
<span class="kt">bool</span> <span class="nf">all_true</span><span class="p">(</span><span class="n">Args</span> <span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="p">(...</span> <span class="o">&amp;&amp;</span> <span class="n">has_value</span><span class="p">(</span><span class="n">args</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Furthermore, fold expressions can be applied to the metafunction <code class="language-plaintext highlighter-rouge">contains_optional</code> where we operate only on types, not actual variables like in the previous case.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">contains_optional</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">value</span> <span class="o">=</span> <span class="p">(...</span> <span class="o">||</span> <span class="n">is_instance_of</span><span class="o">&lt;</span><span class="n">Args</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">);</span>
<span class="p">};</span>

</code></pre></div></div>

<p>A very good strong argument why fold expressions are a valuable addition to the standard is their intuitivity - obtaining simplified and a better understandable code is straightforward and almost immediate.</p>

<h3 id="constexpr-if">Constexpr if</h3>

<p>The main <code class="language-plaintext highlighter-rouge">cppsprintf</code> function requires two seperate implementations, one which always returns an optional string and a standard one selected only well all arguments are always well-defined. Before C++17 it was not possible to simplify this into a single function since all return statements must return a value of the same type. Yet another addition in the new standard is <a href="https://en.cppreference.com/w/cpp/language/if">constexpr if</a>, an if statement where the condition is evaluated at compile time and . With this tool, we can use the knowledge that the arguments pack does not contain any optional value and return a simple string.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
<span class="k">auto</span> <span class="nf">cppsprintf</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">format</span><span class="p">,</span> <span class="n">Args</span> <span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="k">constexpr</span><span class="p">(</span><span class="n">contains_optional</span><span class="o">&lt;</span><span class="n">Args</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">all_true</span><span class="p">(</span><span class="n">args</span><span class="p">...))</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span>
      <span class="n">cppsprintf_impl</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...)</span>
    <span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">cppsprintf_impl</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note the alone <code class="language-plaintext highlighter-rouge">auto</code> in the function header - the returned type is automatically deduced by the compiler and different return statements in the same block have to agree on the type. If it makes you feel uneasy, the auto can be enhanced with a trailing return type which we saw before. However, this time the <a href="https://en.cppreference.com/w/cpp/types/conditional"><code class="language-plaintext highlighter-rouge">std::conditional</code></a> is needed to select type and we obtain <code class="language-plaintext highlighter-rouge">-&gt; typename std::conditional&lt;contains_optional&lt;Args...&gt;::value, std::optional&lt;std::string&gt;, std::string&gt;::type</code>.</p>

<p>The code is published on <a href="https://github.com/mcopik/cpp_samples/blob/master/util/cppsprintf.hpp">GitHub</a>. The support for either LLVM or standard optional can be enabled with definitions <code class="language-plaintext highlighter-rouge">HAVE_LLVM_OPTIONAL</code> and <code class="language-plaintext highlighter-rouge">HAVE_CXX17_OPTIONAL</code>. Fold expressions and constexpr if are also enabled by defining <code class="language-plaintext highlighter-rouge">HAVE_CXX17_FOLD_EXPR</code> and <code class="language-plaintext highlighter-rouge">HAVE_CXX17_CONSTEXPR_IF</code>, respectively, since many popular versions of C++ compilers do not have full C++17 support.</p>

  </article>

  

</div>

    </div>

    <!-- Footer -->

    
<footer class="fixed-bottom">
  <div class="container mt-0">
    &copy; Copyright 2021 Marcin  Copik.
    Powered by <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio">al-folio</a> theme.

    
    
    Last updated: July 20, 2021.
    
  </div>
</footer>

<script type="text/javascript" src="/assets/js/lightbox.js"></script>
<link rel="stylesheet" href="/assets/css/lightbox.css">


  </body>

  <!-- Bootsrap & MDB scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.4.4/umd/popper.min.js" integrity="sha512-eUQ9hGdLjBjY3F41CScH3UX+4JDSI9zXeroz7hJ+RteoCaY+GP/LDoM8AO+Pt+DRFw3nXqsjh9Zsts8hnYv8/A==" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha512-M5KW3ztuIICmVIhjSqXe01oV2bpe248gOxqmlcYrEzAvws7Pw3z6BK0iGbrwvdrUQUhi3eXgtxp5I8PDo9YfjQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/js/mdb.min.js" integrity="sha512-Mug9KHKmroQFMLm93zGrjhibM2z2Obg9l6qFG2qKjXEXkMp/VDkI4uju9m4QKPjWSwQ6O2qzZEnJDEeCw0Blcw==" crossorigin="anonymous"></script>

  
<!-- Mansory & imagesLoaded -->
<script defer src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"></script>
<script defer src="https://unpkg.com/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
<script defer src="/assets/js/mansory.js" type="text/javascript"></script>


  


<!-- Medium Zoom JS -->
<script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script>
<script src="/assets/js/zoom.js"></script>


<!-- Load Common JS -->
<script src="/assets/js/common.js"></script>


</html>
